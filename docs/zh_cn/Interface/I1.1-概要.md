# 概要

> 注意: 本文档是关于 `ProjectInterface` 的编写和使用。
>
> 文中将使用 PI 代指 `ProjectInterface`, Client 代指可以处理 PI 的工具。

## 简介

所谓 `ProjectInterface`, 即 MaaFramework 的一个标准化的项目结构声明, 该声明目前包含 `interface.json` 一个文件。 通过定义 PI, 你可以使用 MaaFramework 的各种衍生工具。 因此, 即使你打算纯粹依靠通用编程语言集成, 也建议定义包含基础信息的 PI。

* MaaPiCli 通用 CLI

* [MFAWPF](https://github.com/SweetSmellFox/MFAWPF) 通用 GUI

* [Maa Pipeline Support](https://marketplace.visualstudio.com/items?itemName=nekosu.maa-support) VSCode 插件

* [项目模板](https://github.com/MaaXYZ/MaaPracticeBoilerplate) 基于 PI 组织的模板

## `interface.json`

> 该文件可以通过 [schema](https://github.com/MaaXYZ/MaaFramework/blob/main/tools/interface.schema.json) 文件获得提示和校验功能。
>
> 使用 VSCode 打开**项目模板**文件夹, 可自动关联 schema 和文件。

### 文件结构

* `version`: *string*

  项目版本, Client 可以展示给用户。

* `message`: *string*

  欢迎语, Client 可以展示给用户。

* `controller`: *list<object,>*

  控制器配置, 为一个对象数组, 含有预设的控制器信息。

  * `name`: *string*

    控制器名称（不应重复）, Client 会展示给用户进行选择。

  * `type`: *string*

    控制器类型, 可选值为 `Adb` | `Win32`。

  * `adb`: *object*

    `Adb 控制器`的具体配置。

    * `input`: *int*

      可选。 Adb 控制器的控制方式, 不提供则使用默认。 具体定义参见 [Adb Input](#adb-input) 。

    * `screencap`: *int*

      可选。 Adb 控制器的截图方式, 不提供则使用默认。 具体定义参见 [Adb Screencap](#adb-screencap) 。

    * `config`: *object*

      可选。Adb 控制器的额外配置, 不提供则使用空对象。 具体定义参见 [Adb Config](#adb-config) 。

  * `win32`: *object*

    `Win32` 控制器的具体配置。

    * `class_regex`: *string*

      可选。 `Win32` 控制器搜索窗口类名使用的正则表达式。

    * `window_regex`: *string*

      可选。 `Win32` 控制器搜索窗口标题使用的正则表达式。

    * `input`: *int*

      可选。 `Win32` 控制器的控制方式, 不提供则使用默认。 具体定义参见 [Win32 Input](#win32-input) 。

    * `screencap`: *int*

      可选。 `Win32` 控制器的截图方式, 不提供则使用默认。 具体定义参见 [Win32 Screencap](#win32-screencap) 。

* `resource`: *list<object,>*

  资源配置, 为一个对象数组, 含有资源加载的信息。

  * `name`: *string*

    资源唯一名称, Client 会展示给用户进行选择。

  * `path`: *list<str,>*

    资源加载的路径数组。 如果提供多个路径, 会依次进行加载, 后加载的资源会覆盖前加载的资源。 详见 [资源覆盖](#资源覆盖)。

    使用 `{PROJECT_DIR}` 来指代 `interface。json` 文件所在的目录, 例如:

    ```json
    "resource": [
        {
            "name": "Official",
            "path": [
                "{PROJECT_DIR}/resource"
            ]
        }
    ]
    ```

    注意: 资源不仅包含 `pipeline`, 也包含 `image` 与 `model`, 因此**不要**直接指定 `pipeline` 目录。

* `task`: *list<object,>*

  任务配置, 为一个对象数组, 含有可执行任务的信息，例如：
    ```json
    "task": [
      {
      "name": "Sample Task1",
      "entry": "Sample Entry1",
      "pipeline_override": {
        "Override Task1": {},
        "Override Task2": {}
        }
      },
      {
      "name": "Sample Task2",
      "entry": "Sample Entry2"
      }
  ]
    ```

  * `name`: *string*

    任务唯一名称, Client 会展示给用户进行选择。

  * `entry`: *string*

    任务入口, 为 `pipeline` 中 `Task` 的名称。

  * `pipeline_override`: *object*

    可选。任务参数, 执行任务时会覆盖已加载的资源。详见 [资源覆盖](#资源覆盖)。\
    该项结构与 `pipeline` 中的 `json` 文件完全一致, 需要包含**任务名**部分， 例如:

    ```json
    "pipeline_override": {
        "Quit": {
            "enabled": true
        }
    }
    ```

  * `option`: *list<str,>*

    可选。任务配置项, 为一个数组, 含有若干后续 `option` 对象中的键的值, Client 会根据要求用户进行选择。

    Client 可以使用 `option` 中的顺序来展示配置项。

* `option`: *object*

  配置项定义, 为一个对象映射, 含有配置项的信息。

  * `key`: *string*

    选项唯一名称, 任务会使用该名称进行引用。

  * `cases`: *list<object,>*

    可选。为一个对象数组, 含有各个可选项的信息。

    Client 可以使用 `cases` 中的顺序来展示可选项。

    * `name`: *string*

      唯一名称, Client 会展示给用户进行选择。

    * `pipeline_override`: *object*

      同 `task` 中的 `pipeline_override` ， 在选项激活时生效。

  * `default_case`: *string*

    可选。默认选项, Client 可以使用该值作为选项的初始值。

### Input 与 Screencap
对于 Input 与 Screencap ，填入 0 代表 Null ，即不使用任何控制/截图方式。这可能会引发报错。除非确有需要，请**不要**填入 0 。
#### Input

定义 MaaFramework 会使用何种方式来控制。

##### Adb Input

> 参考 [MaaDef.h](../../../include/MaaFramework/MaaDef.h#L227-L240)

将下面选择的方式 **按位或** 合并为一个值提供. MaaFramework 将会按照固定优先级顺序尝试所有提供的方式, 选择首个可用方式。可选值: `0` | `1` | `2` | `4` | `8`

默认尝试除 EmulatorExtras 外所有方式。

> 优先级: EmulatorExtras > Maatouch > MinitouchAndAdbKey > AdbShell

* `1` -> AdbShell

  使用 adb 进程进行控制。

* `2` -> MinitouchAndAdbKey

  使用 adb 进程进行按键控制, 使用 minitouch 工具进行触摸控制。

* `4` -> Maatouch

  使用 maatouch 工具控制

* `8` -> EmulatorExtras

  使用模拟器专用接口进行控制。 目前支持的模拟器:

  * 雷电模拟器 9 (9.0.78及以上版本)
  * MuMu 12 模拟器 (4.0及以上版本)

##### Win32 Input

> 参考 [MaaDef.h](../../../include/MaaFramework/MaaDef.h#L252-L259)

选择下面的值提供。

无默认值。 Client 可以选择一个作为默认值。可选值: `0` | `1` | `2`

Win32 下不同程序处理输入的方法不同,，不存在一个通用方式。

* `1` -> Seize

  抢占式控制。 该模式下用户的光标将直接被 MaaFramework 移动, 目标窗口将会保持激活。

* `2` -> SendMessage

  使用 SendMessage 控制。 该模式下目标窗口可以失焦。

#### Screencap

定义 MaaFramework 会使用何种方式来截图。

##### Adb Screencap

> 参考 [MaaDef.h](../../../include/MaaFramework/MaaDef.h#L208-L225)

将下面选择的方式 **按位或** 合并为一个值提供. MaaFramework 将会尝试所有提供的方式, 选择最快的可用方式.

默认尝试除 `RawByNetcat`, `MinicapDirect`, `MinicapStream` 外所有方式。可选值: `0` | `1` | `2` | `4` | `8` | `16` | `32` | `64`

 > `MinicapDirect` 和 `MinicapStream` 由于会编码为 jpg, 为有损编码, 将显著降低模板匹配的效果, 不建议使用。

* `1` -> EncodeToFileAndPull
*
  通过内置 screencap 进程截图, 编码为 png 输出到文件, 通过 adb 进程拉取文件, 读取文件。

* `2` -> Encode

  通过内置 screencap 进程截图, 编码为 png, 通过 adb 进程管道传输。

* `4` -> RawWithGzip

  通过内置 screencap 进程截图, 通过 gzip 压缩, 通过 adb 进程管道传输。

* `8` -> RawByNetcat

  通过内置 screencap 进程截图, 通过 nc 进程网络传输。

* `16` -> MinicapDirect

  通过 minicap 工具截图和编码为 jpg, 通过 adb 进程管道传输。

* `32` -> MinicapStream

  通过 minicap 工具流式截图和编码为 jpg, 通过 adb 进程管道传输。

* `64` -> EmulatorExtras

  使用模拟器专用接口进行截图，需要模拟器支持。目前支持的模拟器：

  * 雷电模拟器 9 (9.0.78及以上版本)
  * MuMu 12 模拟器 (4.0及以上版本)

##### Win32 Screencap

> 参考 [MaaDef.h](../../../include/MaaFramework/MaaDef.h#L242-L250)

选择下面的值提供。

无默认值。 Client 可以选择一个作为默认值。

Win32 下不同程序处理绘制的方法不同, 不存在一个通用方式。

* `1` -> GDI

* `1` -> FramePool

* `4` -> DXGI_DesktopDup

~~写文档的人不知道各个方法时咋搞的~~

### Adb Config

可以通过 config 对象覆盖控制器的部分默认逻辑。 通常只有在使用 `EmulatorExtras` 且进行多开时会需要特定配置。

~~写文档的人不知道应该怎么配置~~

### 资源覆盖

#### 任务 (Task)

后加载的资源中如果发现了和已加载资源同名的任务, 会对任务进行合并。 通常情况下, 可以认为新的任务的顶级键会替换旧任务的。 例如:

  旧任务：

  ```json
  {
      "task1": {
          "enabled": false,
          "recognition": "DirectHit",
          "next": [ "T1", "T2" ]
      }
  }
  ```

  新任务：

  ```json
  {
      "task1": {
          "enabled": true,
          "action": "Click",
          "target": [ 10,10,10,10 ],
          "next": [ "T2", "T3" ]
      }
  }
  ```

  合并后的任务:

  ```jsonc
  {
      "task1": {
          "enabled": true,
          "recognition": "DirectHit",
          "action": "Click",
          "target": [ 10,10,10,10 ],
          "next": [ "T2", "T3" ]       // 直接替换, 内部不会进行合并
      }
  }
  ```


#### 模型 (Model)

待补充。

#### 图像 (Image)

如存在同名图像文件，则使用最后加载资源的图像。